package edu.allegheny.expose;

import java.util.*;
import au.com.bytecode.opencsv.*;
import java.io.FileWriter;
import java.io.FileReader;
import java.io.IOException;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.io.PrintWriter;

/**
 * This class manages the data generated by an experiment
 *
 * @author Cody Kinneer
 */
public class ExperimentResults{

    /** Stores the data from a doubling experiment */
    private List<Double[]> data;

    /** Stores the experiments parameters */
    private String[] expParams;


    /** Supports writing CSV files */
    private CSVWriter writer;

    /** first line for csv output */
    private String[] header;

    // TODO allow import of data in arbitrary format
    

    public ExperimentResults(String CSVDir, String[] header, String[] expParams, boolean append){
        this(CSVDir, header, append);
        this.expParams = expParams;
    }

    /**
     * Constructor initializes data
     * @param CSVDir director to save CSV file to
     */
    public ExperimentResults(String CSVDir, String[] header, boolean append){
        data = new ArrayList<Double[]>(); 
        this.header = header;

        // initialize writer to given dir
        if(CSVDir != null){
        try {
            writer = new CSVWriter(new FileWriter(CSVDir,append));
            // write header
            writer.writeNext(header);
            writer.flush();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        }
    }

    public ExperimentResults(){
        this(null, new String[] {"Doubles","Time"},false);
    }

    public void writeMetafile(int termcode, long runtime, String schema, String criterion, String generator, String doubler, String answer){
        try{
        String filename = "META"+schema+"_"+criterion+"_"+generator+"_"+doubler+".csv";
        String header = "\"schema\",\"criterion\",\"generator\",\"doubler\",\"termcode\",\"runtime\",\"bigOh\"";
        String content = "\""+schema+"\",\""+criterion+"\",\""+generator+"\",\""+doubler+"\","+termcode+","+runtime+",\""+answer+"\"";

        PrintWriter pw = new PrintWriter("data/"+filename);
        pw.println(header);
        pw.println(content);
        pw.flush();
        pw.close();
        }catch(FileNotFoundException e){
            e.printStackTrace();
        }
    }

    //TODO test this method
    /**
     * Outputs data from the experiment to a file
     * @param filename Path of file to save the data to
     */
    public void writeCSV(){
        if (data.isEmpty()){
            System.out.println("No data to print.");
            return;
        }

        // calculate extra size for expParams
        int size = 0;
        if (expParams != null)
            size = expParams.length;
        
        // convert data to string
        List<String[]> convert = new ArrayList<String[]>();
        for (Double[] dub : data){
            String[] replacement = new String[dub.length+size];

            for (int count = 0; count < dub.length; count++){
                replacement[count] = String.valueOf(dub[count]);
            }

            for (int count = 0; count < size; count++){
                replacement[count+dub.length] = expParams[count];
            }

            convert.add(replacement);
        }

        try{
            writer.writeAll(convert);
            writer.flush();
            writer.close();
        }catch(IOException e){
            e.printStackTrace();
        }
    }

    /**
     * Read in a data from a csv file to analyze.
     * Data in the CSV file must have the following format:
     * times doubled, runtime
     * @param name of CSV file
     */
    protected void readCSV(String fileName){

        try{
            // Read in the data from csv
            CSVReader reader = new CSVReader(new FileReader(fileName));
            List<String[]> readIn = reader.readAll();
            reader.close();

            // Convert the data to Double
            List<Double[]> converted = CSVtoDouble(readIn);

            loadData(converted);

        }catch (FileNotFoundException e){
            e.printStackTrace();
        }catch (IOException e){
            e.printStackTrace();
        }
    }

    /**
     * Return this objects data
     * @return data from last experiment
     */
    public List<Double[]> getData(){
        return data;
    }

    /**
     * This method allows data to be read into to the class.
     * it ensures that the data is properly sorted
     * @param input desired experiment data to load in
     */
    public void loadData(List<Double[]> input){

        sort(input);

        data = input;
    }

    /**
     * Sorts list of double arrays by first element
     * @param array of doubles to sort
     */
    private static void sort(List<Double[]> data){
        // Now sort the data for analysis
        // we will sort by the first element, the num of doubles
        Comparator<Double[]> compare = new Comparator<Double[]>() {
            public int compare(Double[] l1, Double[] l2){
                return l1[0].compareTo(l2[0]);
            }
        };

        // use our rule to sort the data
        Collections.sort(data, compare);
    }

    /**
     * This method converts lists of string arrays to double arrays.
     * Utility method to easily handle CSV files
     * @param readIn list of String[] to convert
     * @return a list of Double[]
     */
    private List<Double[]> CSVtoDouble(List<String[]> readIn){

        List<Double[]> data = new ArrayList<Double[]>();

        // Convert the data to Double format
        for (int count = 0; count < readIn.size(); count++){
            try{
                Double[] newData = {Double.valueOf(readIn.get(count)[0]), 
                    Double.valueOf(readIn.get(count)[1])};
                data.add(newData);
            }catch (NumberFormatException e){
                if (count == 0){
                    // if the first line, simply continue, could be a header line
                }else{
                    // otherwise, CSV not valid, trace the stack
                    e.printStackTrace();
                }
            }

        }

        return data;
    }

    /** 
     * Calculate the median for each set of trials. 
     * Sets this objects avg field
     */
    public List<Double[]> aggregate(){

        List<Double[]> avgData = new ArrayList<Double[]>();

        int index = 0; // begin at start of list

        // while there is data left to aggregate
        while(index < data.size()){

            // get the current times doubled
            double set = data.get(index)[0];
            // we will store each result from this data set
            List<Double> setList = new ArrayList<Double>();

            // while the times doubled is the same
            while(index < data.size() && data.get(index)[0] == set){
                // add data to set
                setList.add(data.get(index)[1]);
                // move on to next data
                index++;
            }

            // build a single row from the set
            Double[] row =  {set, centralTendency(setList)};

            avgData.add(row);

        }

        return avgData;

    }

    /**
     * Calculates the median
     * @param input collection of data
     * @return the median of the data
     */
    protected static double centralTendency(List<Double> input){
        Collections.sort(input);
        int mod = input.size() % 2;
        int mid = input.size() / 2;
        // if even
        if (mod == 0){
            return (input.get(mid) + input.get(mid - 1)) / 2;
            // if odd
        }else{
            return input.get(mid);
        }
    }

    /**
     * Gets the ratio of 2N/N for the experiment
     * @param index which ratio to get, where 0 is most recent
     * @return ratio of 2N/N
     */
    public double getRatio(int index){
        List<Double[]> avg = aggregate();
        double ratio = avg.get(avg.size()-1-index)[1] / avg.get(avg.size()-2-index)[1];

        return ratio;
    }

    public void reset(){
        data = new ArrayList<Double[]>();
    }

    // Wrappers for data

    public boolean isEmpty(){
        return data.isEmpty();
    }

    public Double[] get(int index){
        return data.get(index);
    }

    public int size(){
        return data.size();
    }

    /**
     * Addes data to the experiment, flushes data to file
     * @param input array of data to add
     */
    public void add(Double[] input){
        data.add(input);

        int size = 0;
        if (expParams != null)
            size = expParams.length;

        String[] stringOut = new String[input.length+size];

        for (int count = 0; count < input.length; count++){
            stringOut[count] = String.valueOf(input[count]);
        }

        // add in the expParams
         for (int count = 0; count < size; count++){
            stringOut[count+input.length] = expParams[count];
        }

         if(writer != null){
        writer.writeNext(stringOut);

        try {
            writer.flush();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
         }
    }

}
